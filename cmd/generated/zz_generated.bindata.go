// Code generated for package generated by go-bindata DO NOT EDIT. (@generated)
// sources:
// docs/resources/boot-beauty.ign
// docs/resources/discovery-beauty.ign
// docs/resources/extract-images.sh
// docs/resources/test-boot-beauty.ign
// docs/resources/test-discovery-beauty.ign
package generated

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

// Name return file name
func (fi bindataFileInfo) Name() string {
	return fi.name
}

// Size return file size
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}

// Mode return file mode
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}

// Mode return file modify time
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}

// IsDir return file whether a directory
func (fi bindataFileInfo) IsDir() bool {
	return fi.mode&os.ModeDir != 0
}

// Sys return file is sys mode
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _bootBeautyIgn = []byte(`{
  "ignition": {
    "version": "3.1.0"
  },
  "systemd": {
    "units": [
      {
        "name": "precache-ocp-images.service",
        "enabled": true,
        "contents": "[Unit]\nDescription=Load prestaged OCP images into containers storage\nBefore=machine-config-daemon-pull.service nodeip-configuration.service\n\n[Service]\nType=oneshot\nUser=root\nWorkingDirectory=/var/mnt\nExecStart=bash /usr/local/bin/extract-ocp.sh --label data\nTimeoutStopSec=60\nExecStopPost=systemctl disable precache-ocp-images.service\n\n[Install]\nWantedBy=multi-user.target\n"
      }
    ]
  },
  "storage": {
    "files": [
      {
        "overwrite": true,
        "path": "/usr/local/bin/extract-ocp.sh",
        "mode": 493,
        "user": {
          "name": "root"
        },
        "contents": {
          "source": "data:text/plain;charset=utf-8;base64,IyEvYmluL2Jhc2gKIwojIFV0aWxpdHkgZm9yIGxvYWRpbmcgcHJlc3RhZ2VkIGltYWdlcyBkdXJpbmcgbm9kZSBpbnN0YWxsYXRpb24KIwoKUFJPRz0kKGJhc2VuYW1lICIkMCIpCgpEQVRBRElSPSIvdG1wL3ByZXN0YWdpbmciCkZTPSIvZGV2L2Rpc2svYnktcGFydGxhYmVsL2RhdGEiCgojIERldGVybWluZSB0aGUgaW1hZ2UgbGlzdCBmcm9tIHRoZSBzY3JpcHQgbmFtZSwgZXh0cmFjdC1haS5zaCBvciBleHRyYWN0LW9jcC5zaApJTUdfR1JPVVA9JChlY2hvICIke1BST0d9IiB8IHNlZCAtciAncy8uKmV4dHJhY3QtKC4qKVwuc2gvXDEvJykKSU1HX0xJU1RfRklMRT0iJHtEQVRBRElSfS8ke0lNR19HUk9VUH0taW1hZ2VzLnR4dCIKTUFQUElOR19GSUxFPSIke0RBVEFESVJ9L21hcHBpbmcudHh0IgoKIyBTZXQgdGhlIHBhcmFsbGVsaXphdGlvbiBqb2IgcG9vbCBzaXplIHRvIDgwJSBvZiB0aGUgY29yZXMKQ1BVUz0kKG5wcm9jIC0tYWxsKQpNQVhfQ1BVX01VTFQ9MC44CkpPQl9QT09MX1NJWkU9JChqcSAtbiAiJENQVVMqJE1BWF9DUFVfTVVMVCIgfCBjdXQgLWQgLiAtZjEpCgojIEdldCBpbml0aWFsIHN0YXJ0aW5nIHBvaW50IGZvciBpbmZvIGxvZyBhdCBlbmQgb2YgZXhlY3V0aW9uClNUQVJUPSR7U0VDT05EU30KCiMKIyBjbGVhbnVwOiBDbGVhbiB1cCByZXNvdXJjZXMgb24gZXhpdAojCmZ1bmN0aW9uIGNsZWFudXAgewogICAgY2QgLwogICAgaWYgbW91bnRwb2ludCAtcSAiJHtEQVRBRElSfSI7IHRoZW4KICAgICAgICB1bW91bnQgIiR7REFUQURJUn0iCiAgICBmaQoKICAgIHJtIC1yZiAiJHtEQVRBRElSfSIKfQoKdHJhcCBjbGVhbnVwIEVYSVQKCiMKIyB1c2FnZToKIwpmdW5jdGlvbiB1c2FnZSB7CiAgICBjYXQgPDxFT0YKVXNhZ2U6ICR7UFJPR30gWyAtLWxhYmVsIDxwYXJ0aXRpb24tbGFiZWw+IF0KClBhcmFtZXRlcnM6CiAgICAtLWxhYmVsIDxwYXJ0aXRpb24tbGFiZWw+ICAgICAgTGFiZWwgZm9yIHBhcnRpdGlvbiB0aGF0IGhvbGRzIHRoZSBkb3dubG9hZGVkIGltYWdlcyBhbmQgYXNzb2NpYXRlZCBmaWxlcy4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0OiBkYXRhCgpFT0YKICAgIGV4aXQgMQp9CgojCiMgbW91bnRfZGF0YToKIwpmdW5jdGlvbiBtb3VudF9kYXRhIHsKICAgIGlmICEgbWtkaXIgLXAgIiR7REFUQURJUn0iOyB0aGVuCiAgICAgICAgZWNobyAiJHtQUk9HfTogW0ZBSUxdIEZhaWxlZCB0byBjcmVhdGUgJHtEQVRBRElSfSIKICAgICAgICBleGl0IDEKICAgIGZpCgogICAgaWYgWyAhIC1iICIke0ZTfSIgXTsgdGhlbgogICAgICAgIGVjaG8gIiR7UFJPR306IFtGQUlMXSBOb3QgYSBibG9jayBkZXZpY2U6ICR7RlN9IgogICAgICAgIGV4aXQgMQogICAgZmkKCiAgICBpZiAhIG1vdW50ICIke0ZTfSIgIiR7REFUQURJUn0iOyB0aGVuCiAgICAgICAgZWNobyAiJHtQUk9HfTogW0ZBSUxdIEZhaWxlZCB0byBtb3VudCAke0ZTfSIKICAgICAgICBleGl0IDEKICAgIGZpCgogICAgZm9yIGYgaW4gIiR7SU1HX0xJU1RfRklMRX0iICIke01BUFBJTkdfRklMRX0iOyBkbwogICAgICAgIGlmIFsgISAtZiAiJHtmfSIgXTsgdGhlbgogICAgICAgICAgICBlY2hvICIke1BST0d9OiBbRkFJTF0gQ291bGQgbm90IGZpbmQgJHtmfSIKICAgICAgICAgICAgZXhpdCAxCiAgICAgICAgZmkKICAgIGRvbmUKCiAgICBpZiAhIHB1c2hkICIke0RBVEFESVJ9IjsgdGhlbgogICAgICAgIGVjaG8gIiR7UFJPR306IFtGQUlMXSBGYWlsZWQgdG8gY2hkaXIgdG8gJHtEQVRBRElSfSIKICAgICAgICBleGl0IDEKICAgIGZpCn0KCiMKIyBjb3B5X2ltYWdlOiBGdW5jdGlvbiB0aGF0IGhhbmRsZXMgZXh0cmFjdGluZyBhbiBpbWFnZSB0YXJiYWxsIGFuZCBjb3B5aW5nIGl0IGludG8gY29udGFpbmVyIHN0b3JhZ2UuCiMgICAgICAgICAgICAgTGF1bmNoZWQgaW4gYmFja2dyb3VuZCBmb3IgcGFyYWxsZWxpemF0aW9uLCBvciBpbmxpbmUgZm9yIHJldHJpZXMKIwpmdW5jdGlvbiBjb3B5X2ltYWdlIHsKICAgIGxvY2FsIGN1cnJlbnRfY29weT0kMQogICAgbG9jYWwgdG90YWxfY29waWVzPSQyCiAgICBsb2NhbCB1cmk9JDMKICAgIGxvY2FsIHRhZz0kNAogICAgbG9jYWwgcmM9MAogICAgbG9jYWwgbmFtZT0KCiAgICBlY2hvICIke1BST0d9OiBbREVCVUddIEV4dHJhY3RpbmcgaW1hZ2UgJHt1cml9IgogICAgbmFtZT0kKGJhc2VuYW1lICIke3VyaS86L199IikKICAgIGlmICEgdGFyIC0tdXNlLWNvbXByZXNzLXByb2dyYW09cGlneiAteGYgIiR7bmFtZX0udGd6IjsgdGhlbgogICAgICAgIGVjaG8gIiR7UFJPR306IFtFUlJPUl0gQ291bGQgbm90IGV4dHJhY3QgdGhlIGltYWdlICR7bmFtZX0udGd6IgogICAgICAgIHJldHVybiAxCiAgICBmaQoKICAgIGlmIFtbICIke0lNR19HUk9VUH0iID0gImFpIiAmJiAtbiAiJHt0YWd9IiAmJiAiJHt1cml9IiA9fiAiQHNoYSIgXV07IHRoZW4KICAgICAgICAjIER1cmluZyB0aGUgQUkgbG9hZGluZyBzdGFnZSwgaWYgdGhlIGltYWdlIGhhcyBhIHRhZywgbG9hZCB0aGF0IGludG8gY29udGFpbmVyIHN0b3JhZ2UgYXMgd2VsbAogICAgICAgIGVjaG8gIiR7UFJPR306IFtJTkZPXSBDb3B5aW5nICR7dXJpfSwgd2l0aCB0YWcgJHt0YWd9IFske2N1cnJlbnRfY29weX0vJHt0b3RhbF9jb3BpZXN9XSIKICAgICAgICBub3RhZz0ke3VyaS9AKn0KICAgICAgICBza29wZW8gY29weSAtLXJldHJ5LXRpbWVzIDEwICJkaXI6Ly8ke1BXRH0vJHtuYW1lfSIgImNvbnRhaW5lcnMtc3RvcmFnZToke3VyaX0iIC1xICYmIFwKICAgICAgICAgICAgc2tvcGVvIGNvcHkgLS1yZXRyeS10aW1lcyAxMCAiZGlyOi8vJHtQV0R9LyR7bmFtZX0iICJjb250YWluZXJzLXN0b3JhZ2U6JHtub3RhZ306JHt0YWd9IiAtcQogICAgICAgIHJjPSQ/CiAgICBlbHNlCiAgICAgICAgZWNobyAiJHtQUk9HfTogW0lORk9dIENvcHlpbmcgJHt1cml9IFske2N1cnJlbnRfY29weX0vJHt0b3RhbF9jb3BpZXN9XSIKICAgICAgICBza29wZW8gY29weSAtLXJldHJ5LXRpbWVzIDEwICJkaXI6Ly8ke1BXRH0vJHtuYW1lfSIgImNvbnRhaW5lcnMtc3RvcmFnZToke3VyaX0iIC1xCiAgICAgICAgcmM9JD8KICAgIGZpCgogICAgZWNobyAiJHtQUk9HfTogW0lORk9dIFJlbW92aW5nIGZvbGRlciBmb3IgJHt1cml9IgogICAgcm0gLXJmICIke25hbWV9IgoKICAgIHJldHVybiAke3JjfQp9CgojCiMgbG9hZF9pbWFnZXM6IExhdW5jaCBqb2JzIHRvIHByZXN0YWdlIGltYWdlcyBmcm9tIHRoZSBhcHByb3ByaWF0ZSBsaXN0IGZpbGUKIwpmdW5jdGlvbiBsb2FkX2ltYWdlcyB7CiAgICBsb2NhbCAtQSBwaWRzICMgSGFzaCB0aGF0IGluY2x1ZGUgdGhlIGltYWdlcyBwdWxsZWQgYWxvbmcgd2l0aCB0aGVpciBwaWRzIHRvIGJlIG1vbml0b3JlZCBieSB3YWl0IGNvbW1hbmQKICAgIGxvY2FsIC1hIGltYWdlcwogICAgbWFwZmlsZSAtdCBpbWFnZXMgPCA8KCBzb3J0IC11ICIke0lNR19MSVNUX0ZJTEV9IiApCgogICAgbG9jYWwgdG90YWxfY29waWVzPSR7I2ltYWdlc1tAXX0KICAgIGxvY2FsIGN1cnJlbnRfY29weT0wCiAgICBsb2NhbCBqb2JfY291bnQ9MAoKICAgIGVjaG8gIiR7UFJPR306IFtJTkZPXSBSZWFkeSB0byBleHRyYWN0ICR7dG90YWxfY29waWVzfSBpbWFnZXMgdXNpbmcgJEpPQl9QT09MX1NJWkUgc2ltdWx0YW5lb3VzIHByb2Nlc3NlcyIKCiAgICBmb3IgdXJpIGluICIke2ltYWdlc1tAXX0iOyBkbwogICAgICAgIGN1cnJlbnRfY29weT0kKChjdXJyZW50X2NvcHkrMSkpCgogICAgICAgICMgQ2hlY2sgdGhhdCB3ZSd2ZSBnb3QgZnJlZSBzcGFjZSBpbiB0aGUgam9iIHBvb2wKICAgICAgICB3aGlsZSBbICIke2pvYl9jb3VudH0iIC1nZSAiJHtKT0JfUE9PTF9TSVpFfSIgXTsgZG8KICAgICAgICAgICAgc2xlZXAgMC4xCiAgICAgICAgICAgIGpvYl9jb3VudD0kKGpvYnMgfCB3YyAtbCkKICAgICAgICBkb25lCgogICAgICAgIGVjaG8gIiR7UFJPR306IFtERUJVR10gUHJvY2Vzc2luZyBpbWFnZSAke3VyaX0iCiAgICAgICAgaWYgcG9kbWFuIGltYWdlIGV4aXN0cyAiJHt1cml9IjsgdGhlbgogICAgICAgICAgICBlY2hvICIke1BST0d9OiBbSU5GT10gU2tpcHBpbmcgZXhpc3RpbmcgaW1hZ2UgJHt1cml9IFske2N1cnJlbnRfY29weX0vJHt0b3RhbF9jb3BpZXN9XSIKICAgICAgICAgICAgY29udGludWUKICAgICAgICBmaQoKICAgICAgICB0YWc9JChncmVwICJeJHt1cml9PSIgIiR7TUFQUElOR19GSUxFfSIgfCBzZWQgJ3MvLio6Ly8nKQogICAgICAgIGNvcHlfaW1hZ2UgIiR7Y3VycmVudF9jb3B5fSIgIiR7dG90YWxfY29waWVzfSIgIiR7dXJpfSIgIiR7dGFnfSIgJgoKICAgICAgICBwaWRzWyR7dXJpfV09JCEgIyBLZWVwaW5nIHRyYWNrIG9mIHRoZSBQSUQgYW5kIGNvbnRhaW5lciBpbWFnZSBpbiBjYXNlIHRoZSBwdWxsIGZhaWxzCiAgICBkb25lCgogICAgZWNobyAiJHtQUk9HfTogW0RFQlVHXSBXYWl0aW5nIGZvciBqb2IgY29tcGxldGlvbiIKICAgIGZvciBpbWcgaW4gIiR7IXBpZHNbQF19IjsgZG8KICAgICAgICAjIFdhaXQgZm9yIGVhY2ggYmFja2dyb3VuZCB0YXNrIChQSUQpLiBJZiBhbnkgZXJyb3IsIHRoZW4gY29weSB0aGUgaW1hZ2UgaW4gdGhlIGZhaWxlZCBhcnJheSBzbyBpdCBjYW4gYmUgcmV0cmllZCBsYXRlcgogICAgICAgIGlmICEgd2FpdCAiJHtwaWRzWyRpbWddfSI7IHRoZW4KICAgICAgICAgICAgZWNobyAiJHtQUk9HfTogW0VSUk9SXSBQdWxsIGZhaWxlZCBmb3IgY29udGFpbmVyIGltYWdlOiAke2ltZ30gLiBSZXRyeWluZyBsYXRlci4uLiAiCiAgICAgICAgICAgIGZhaWxlZF9jb3BpZXMrPSgiJHtpbWd9IikgIyBGYWlsZWQsIHRoZW4gYWRkIHRoZSBpbWFnZSB0byBiZSByZXRyaWV2ZWQgbGF0ZXIKICAgICAgICBmaQogICAgZG9uZQp9CgojCiMgcmV0cnlfaW1hZ2VzOiBSZXRyeSBsb2FkaW5nIGFueSBmYWlsZWQgaW1hZ2VzIGludG8gY29udGFpbmVyIHN0b3JhZ2UKIwpmdW5jdGlvbiByZXRyeV9pbWFnZXMgewogICAgbG9jYWwgdG90YWxfY29waWVzPSR7I2ZhaWxlZF9jb3BpZXNbQF19CgogICAgaWYgWyAiJHt0b3RhbF9jb3BpZXN9IiAtZXEgMCBdOyB0aGVuCiAgICAgICAgcmV0dXJuIDAKICAgIGZpCgogICAgbG9jYWwgcmM9MAogICAgbG9jYWwgdGFnCiAgICBsb2NhbCBjdXJyZW50X2NvcHk9MAoKICAgIGVjaG8gIiR7UFJPR306IFtSRVRSWUlOR10iCiAgICBmb3IgZmFpbGVkX2NvcHkgaW4gIiR7ZmFpbGVkX2NvcGllc1tAXX0iOyBkbwogICAgICAgIGN1cnJlbnRfY29weT0kKChjdXJyZW50X2NvcHkrMSkpCgogICAgICAgIGVjaG8gIiR7UFJPR306IFtSRVRSWV0gUmV0cnlpbmcgZmFpbGVkIGltYWdlIHB1bGw6ICR7ZmFpbGVkX2NvcHl9IgoKICAgICAgICB0YWc9JChncmVwICJeJHt1cml9PSIgIiR7TUFQUElOR19GSUxFfSIgfCBzZWQgJ3MvLio6Ly8nKQogICAgICAgIGNvcHlfaW1hZ2UgIiR7Y3VycmVudF9jb3B5fSIgIiR7dG90YWxfY29waWVzfSIgIiR7dXJpfSIgIiR7dGFnfSIKICAgICAgICByYz0kPwogICAgZG9uZQoKICAgIGVjaG8gIiR7UFJPR306IFtJTkZPXSBJbWFnZSBsb2FkIGRvbmUiCiAgICByZXR1cm4gIiR7cmN9Igp9CgppZiBbWyAiJHtCQVNIX1NPVVJDRVswXX0iID0gIiR7MH0iIF1dOyB0aGVuCiAgICAjCiAgICAjIFByb2Nlc3MgY21kbGluZSBhcmd1bWVudHMKICAgICMKCiAgICBsb25nb3B0cz0oCiAgICAgICAgImhlbHAiCiAgICAgICAgImxhYmVsOiIKICAgICkKCiAgICBsb25nb3B0c19zdHI9JChJRlM9LDsgZWNobyAiJHtsb25nb3B0c1sqXX0iKQoKICAgIGlmICEgT1BUUz0kKGdldG9wdCAtbyAiaGw6IiAtLWxvbmcgIiR7bG9uZ29wdHNfc3RyfSIgLS1uYW1lICIkMCIgLS0gIiRAIik7IHRoZW4KICAgICAgICB1c2FnZQogICAgICAgIGV4aXQgMQogICAgZmkKCiAgICBldmFsIHNldCAtLSAiJHtPUFRTfSIKCiAgICB3aGlsZSA6OyBkbwogICAgICAgIGNhc2UgIiQxIiBpbgogICAgICAgICAgICAtbHwtLWxhYmVsKQogICAgICAgICAgICAgICAgRlM9Ii9kZXYvZGlzay9ieS1wYXJ0bGFiZWwvJHsyfSIKICAgICAgICAgICAgICAgIHNoaWZ0IDIKICAgICAgICAgICAgICAgIDs7CiAgICAgICAgICAgIC0tKQogICAgICAgICAgICAgICAgc2hpZnQKICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICA7OwogICAgICAgICAgICAtaHwtLWhlbHApCiAgICAgICAgICAgICAgICB1c2FnZQogICAgICAgICAgICAgICAgOzsKICAgICAgICAgICAgKikKICAgICAgICAgICAgICAgIHVzYWdlCiAgICAgICAgICAgICAgICA7OwogICAgICAgIGVzYWMKICAgIGRvbmUKCiAgICBmYWlsZWRfY29waWVzPSgpICMgQXJyYXkgdGhhdCB3aWxsIGluY2x1ZGUgYWxsIHRoZSBpbWFnZXMgdGhhdCBmYWlsZWQgdG8gYmUgcHVsbGVkCgogICAgbW91bnRfZGF0YQoKICAgIGxvYWRfaW1hZ2VzCgogICAgaWYgISByZXRyeV9pbWFnZXM7IHRoZW4KICAgICAgICBlY2hvICIke1BST0d9OiBbRkFJTF0gJHsjZmFpbGVkX2NvcGllc1tAXX0gaW1hZ2VzIHdlcmUgbm90IGxvYWRlZCBzdWNjZXNzZnVsbHksIGFmdGVyICQoKFNFQ09ORFMtU1RBUlQpKSBzZWNvbmRzIiAjbnVtYmVyIG9mIGZhaWxpbmcgaW1hZ2VzCiAgICAgICAgZXhpdCAxCiAgICBlbHNlCiAgICAgICAgZWNobyAiJHtQUk9HfTogW1NVQ0NFU1NdIEFsbCBpbWFnZXMgd2VyZSBsb2FkZWQsIGluICQoKFNFQ09ORFMtU1RBUlQpKSBzZWNvbmRzIgogICAgICAgIGV4aXQgMAogICAgZmkKZmkK"
        }
      }
    ]
  }
}
`)

func bootBeautyIgnBytes() ([]byte, error) {
	return _bootBeautyIgn, nil
}

func bootBeautyIgn() (*asset, error) {
	bytes, err := bootBeautyIgnBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "boot-beauty.ign", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _discoveryBeautyIgn = []byte(`{
  "ignition": {
    "version": "3.1.0"
  },
  "systemd": {
    "units": [
      {
        "name": "precache-images.service",
        "enabled": true,
        "contents": "[Unit]\nDescription=Load prestaged images in discovery stage\n\nBefore=agent.service\n\n[Service]\nType=oneshot\nUser=root\nWorkingDirectory=/var/mnt\nExecStart=bash /usr/local/bin/extract-ai.sh --label data\n#TimeoutStopSec=30\nExecStopPost=systemctl disable precache-images.service\n\n[Install]\nWantedBy=multi-user.target default.target\nWantedBy=agent.service"
      }
    ]
  },
  "storage": {
    "files": [
      {
        "overwrite": true,
        "path": "/usr/local/bin/extract-ai.sh",
        "mode": 493,
        "user": {
          "name": "root"
        },
        "contents": {
          "source": "data:text/plain;charset=utf-8;base64,IyEvYmluL2Jhc2gKIwojIFV0aWxpdHkgZm9yIGxvYWRpbmcgcHJlc3RhZ2VkIGltYWdlcyBkdXJpbmcgbm9kZSBpbnN0YWxsYXRpb24KIwoKUFJPRz0kKGJhc2VuYW1lICIkMCIpCgpEQVRBRElSPSIvdG1wL3ByZXN0YWdpbmciCkZTPSIvZGV2L2Rpc2svYnktcGFydGxhYmVsL2RhdGEiCgojIERldGVybWluZSB0aGUgaW1hZ2UgbGlzdCBmcm9tIHRoZSBzY3JpcHQgbmFtZSwgZXh0cmFjdC1haS5zaCBvciBleHRyYWN0LW9jcC5zaApJTUdfR1JPVVA9JChlY2hvICIke1BST0d9IiB8IHNlZCAtciAncy8uKmV4dHJhY3QtKC4qKVwuc2gvXDEvJykKSU1HX0xJU1RfRklMRT0iJHtEQVRBRElSfS8ke0lNR19HUk9VUH0taW1hZ2VzLnR4dCIKTUFQUElOR19GSUxFPSIke0RBVEFESVJ9L21hcHBpbmcudHh0IgoKIyBTZXQgdGhlIHBhcmFsbGVsaXphdGlvbiBqb2IgcG9vbCBzaXplIHRvIDgwJSBvZiB0aGUgY29yZXMKQ1BVUz0kKG5wcm9jIC0tYWxsKQpNQVhfQ1BVX01VTFQ9MC44CkpPQl9QT09MX1NJWkU9JChqcSAtbiAiJENQVVMqJE1BWF9DUFVfTVVMVCIgfCBjdXQgLWQgLiAtZjEpCgojIEdldCBpbml0aWFsIHN0YXJ0aW5nIHBvaW50IGZvciBpbmZvIGxvZyBhdCBlbmQgb2YgZXhlY3V0aW9uClNUQVJUPSR7U0VDT05EU30KCiMKIyBjbGVhbnVwOiBDbGVhbiB1cCByZXNvdXJjZXMgb24gZXhpdAojCmZ1bmN0aW9uIGNsZWFudXAgewogICAgY2QgLwogICAgaWYgbW91bnRwb2ludCAtcSAiJHtEQVRBRElSfSI7IHRoZW4KICAgICAgICB1bW91bnQgIiR7REFUQURJUn0iCiAgICBmaQoKICAgIHJtIC1yZiAiJHtEQVRBRElSfSIKfQoKdHJhcCBjbGVhbnVwIEVYSVQKCiMKIyB1c2FnZToKIwpmdW5jdGlvbiB1c2FnZSB7CiAgICBjYXQgPDxFT0YKVXNhZ2U6ICR7UFJPR30gWyAtLWxhYmVsIDxwYXJ0aXRpb24tbGFiZWw+IF0KClBhcmFtZXRlcnM6CiAgICAtLWxhYmVsIDxwYXJ0aXRpb24tbGFiZWw+ICAgICAgTGFiZWwgZm9yIHBhcnRpdGlvbiB0aGF0IGhvbGRzIHRoZSBkb3dubG9hZGVkIGltYWdlcyBhbmQgYXNzb2NpYXRlZCBmaWxlcy4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0OiBkYXRhCgpFT0YKICAgIGV4aXQgMQp9CgojCiMgbW91bnRfZGF0YToKIwpmdW5jdGlvbiBtb3VudF9kYXRhIHsKICAgIGlmICEgbWtkaXIgLXAgIiR7REFUQURJUn0iOyB0aGVuCiAgICAgICAgZWNobyAiJHtQUk9HfTogW0ZBSUxdIEZhaWxlZCB0byBjcmVhdGUgJHtEQVRBRElSfSIKICAgICAgICBleGl0IDEKICAgIGZpCgogICAgaWYgWyAhIC1iICIke0ZTfSIgXTsgdGhlbgogICAgICAgIGVjaG8gIiR7UFJPR306IFtGQUlMXSBOb3QgYSBibG9jayBkZXZpY2U6ICR7RlN9IgogICAgICAgIGV4aXQgMQogICAgZmkKCiAgICBpZiAhIG1vdW50ICIke0ZTfSIgIiR7REFUQURJUn0iOyB0aGVuCiAgICAgICAgZWNobyAiJHtQUk9HfTogW0ZBSUxdIEZhaWxlZCB0byBtb3VudCAke0ZTfSIKICAgICAgICBleGl0IDEKICAgIGZpCgogICAgZm9yIGYgaW4gIiR7SU1HX0xJU1RfRklMRX0iICIke01BUFBJTkdfRklMRX0iOyBkbwogICAgICAgIGlmIFsgISAtZiAiJHtmfSIgXTsgdGhlbgogICAgICAgICAgICBlY2hvICIke1BST0d9OiBbRkFJTF0gQ291bGQgbm90IGZpbmQgJHtmfSIKICAgICAgICAgICAgZXhpdCAxCiAgICAgICAgZmkKICAgIGRvbmUKCiAgICBpZiAhIHB1c2hkICIke0RBVEFESVJ9IjsgdGhlbgogICAgICAgIGVjaG8gIiR7UFJPR306IFtGQUlMXSBGYWlsZWQgdG8gY2hkaXIgdG8gJHtEQVRBRElSfSIKICAgICAgICBleGl0IDEKICAgIGZpCn0KCiMKIyBjb3B5X2ltYWdlOiBGdW5jdGlvbiB0aGF0IGhhbmRsZXMgZXh0cmFjdGluZyBhbiBpbWFnZSB0YXJiYWxsIGFuZCBjb3B5aW5nIGl0IGludG8gY29udGFpbmVyIHN0b3JhZ2UuCiMgICAgICAgICAgICAgTGF1bmNoZWQgaW4gYmFja2dyb3VuZCBmb3IgcGFyYWxsZWxpemF0aW9uLCBvciBpbmxpbmUgZm9yIHJldHJpZXMKIwpmdW5jdGlvbiBjb3B5X2ltYWdlIHsKICAgIGxvY2FsIGN1cnJlbnRfY29weT0kMQogICAgbG9jYWwgdG90YWxfY29waWVzPSQyCiAgICBsb2NhbCB1cmk9JDMKICAgIGxvY2FsIHRhZz0kNAogICAgbG9jYWwgcmM9MAogICAgbG9jYWwgbmFtZT0KCiAgICBlY2hvICIke1BST0d9OiBbREVCVUddIEV4dHJhY3RpbmcgaW1hZ2UgJHt1cml9IgogICAgbmFtZT0kKGJhc2VuYW1lICIke3VyaS86L199IikKICAgIGlmICEgdGFyIC0tdXNlLWNvbXByZXNzLXByb2dyYW09cGlneiAteGYgIiR7bmFtZX0udGd6IjsgdGhlbgogICAgICAgIGVjaG8gIiR7UFJPR306IFtFUlJPUl0gQ291bGQgbm90IGV4dHJhY3QgdGhlIGltYWdlICR7bmFtZX0udGd6IgogICAgICAgIHJldHVybiAxCiAgICBmaQoKICAgIGlmIFtbICIke0lNR19HUk9VUH0iID0gImFpIiAmJiAtbiAiJHt0YWd9IiAmJiAiJHt1cml9IiA9fiAiQHNoYSIgXV07IHRoZW4KICAgICAgICAjIER1cmluZyB0aGUgQUkgbG9hZGluZyBzdGFnZSwgaWYgdGhlIGltYWdlIGhhcyBhIHRhZywgbG9hZCB0aGF0IGludG8gY29udGFpbmVyIHN0b3JhZ2UgYXMgd2VsbAogICAgICAgIGVjaG8gIiR7UFJPR306IFtJTkZPXSBDb3B5aW5nICR7dXJpfSwgd2l0aCB0YWcgJHt0YWd9IFske2N1cnJlbnRfY29weX0vJHt0b3RhbF9jb3BpZXN9XSIKICAgICAgICBub3RhZz0ke3VyaS9AKn0KICAgICAgICBza29wZW8gY29weSAtLXJldHJ5LXRpbWVzIDEwICJkaXI6Ly8ke1BXRH0vJHtuYW1lfSIgImNvbnRhaW5lcnMtc3RvcmFnZToke3VyaX0iIC1xICYmIFwKICAgICAgICAgICAgc2tvcGVvIGNvcHkgLS1yZXRyeS10aW1lcyAxMCAiZGlyOi8vJHtQV0R9LyR7bmFtZX0iICJjb250YWluZXJzLXN0b3JhZ2U6JHtub3RhZ306JHt0YWd9IiAtcQogICAgICAgIHJjPSQ/CiAgICBlbHNlCiAgICAgICAgZWNobyAiJHtQUk9HfTogW0lORk9dIENvcHlpbmcgJHt1cml9IFske2N1cnJlbnRfY29weX0vJHt0b3RhbF9jb3BpZXN9XSIKICAgICAgICBza29wZW8gY29weSAtLXJldHJ5LXRpbWVzIDEwICJkaXI6Ly8ke1BXRH0vJHtuYW1lfSIgImNvbnRhaW5lcnMtc3RvcmFnZToke3VyaX0iIC1xCiAgICAgICAgcmM9JD8KICAgIGZpCgogICAgZWNobyAiJHtQUk9HfTogW0lORk9dIFJlbW92aW5nIGZvbGRlciBmb3IgJHt1cml9IgogICAgcm0gLXJmICIke25hbWV9IgoKICAgIHJldHVybiAke3JjfQp9CgojCiMgbG9hZF9pbWFnZXM6IExhdW5jaCBqb2JzIHRvIHByZXN0YWdlIGltYWdlcyBmcm9tIHRoZSBhcHByb3ByaWF0ZSBsaXN0IGZpbGUKIwpmdW5jdGlvbiBsb2FkX2ltYWdlcyB7CiAgICBsb2NhbCAtQSBwaWRzICMgSGFzaCB0aGF0IGluY2x1ZGUgdGhlIGltYWdlcyBwdWxsZWQgYWxvbmcgd2l0aCB0aGVpciBwaWRzIHRvIGJlIG1vbml0b3JlZCBieSB3YWl0IGNvbW1hbmQKICAgIGxvY2FsIC1hIGltYWdlcwogICAgbWFwZmlsZSAtdCBpbWFnZXMgPCA8KCBzb3J0IC11ICIke0lNR19MSVNUX0ZJTEV9IiApCgogICAgbG9jYWwgdG90YWxfY29waWVzPSR7I2ltYWdlc1tAXX0KICAgIGxvY2FsIGN1cnJlbnRfY29weT0wCiAgICBsb2NhbCBqb2JfY291bnQ9MAoKICAgIGVjaG8gIiR7UFJPR306IFtJTkZPXSBSZWFkeSB0byBleHRyYWN0ICR7dG90YWxfY29waWVzfSBpbWFnZXMgdXNpbmcgJEpPQl9QT09MX1NJWkUgc2ltdWx0YW5lb3VzIHByb2Nlc3NlcyIKCiAgICBmb3IgdXJpIGluICIke2ltYWdlc1tAXX0iOyBkbwogICAgICAgIGN1cnJlbnRfY29weT0kKChjdXJyZW50X2NvcHkrMSkpCgogICAgICAgICMgQ2hlY2sgdGhhdCB3ZSd2ZSBnb3QgZnJlZSBzcGFjZSBpbiB0aGUgam9iIHBvb2wKICAgICAgICB3aGlsZSBbICIke2pvYl9jb3VudH0iIC1nZSAiJHtKT0JfUE9PTF9TSVpFfSIgXTsgZG8KICAgICAgICAgICAgc2xlZXAgMC4xCiAgICAgICAgICAgIGpvYl9jb3VudD0kKGpvYnMgfCB3YyAtbCkKICAgICAgICBkb25lCgogICAgICAgIGVjaG8gIiR7UFJPR306IFtERUJVR10gUHJvY2Vzc2luZyBpbWFnZSAke3VyaX0iCiAgICAgICAgaWYgcG9kbWFuIGltYWdlIGV4aXN0cyAiJHt1cml9IjsgdGhlbgogICAgICAgICAgICBlY2hvICIke1BST0d9OiBbSU5GT10gU2tpcHBpbmcgZXhpc3RpbmcgaW1hZ2UgJHt1cml9IFske2N1cnJlbnRfY29weX0vJHt0b3RhbF9jb3BpZXN9XSIKICAgICAgICAgICAgY29udGludWUKICAgICAgICBmaQoKICAgICAgICB0YWc9JChncmVwICJeJHt1cml9PSIgIiR7TUFQUElOR19GSUxFfSIgfCBzZWQgJ3MvLio6Ly8nKQogICAgICAgIGNvcHlfaW1hZ2UgIiR7Y3VycmVudF9jb3B5fSIgIiR7dG90YWxfY29waWVzfSIgIiR7dXJpfSIgIiR7dGFnfSIgJgoKICAgICAgICBwaWRzWyR7dXJpfV09JCEgIyBLZWVwaW5nIHRyYWNrIG9mIHRoZSBQSUQgYW5kIGNvbnRhaW5lciBpbWFnZSBpbiBjYXNlIHRoZSBwdWxsIGZhaWxzCiAgICBkb25lCgogICAgZWNobyAiJHtQUk9HfTogW0RFQlVHXSBXYWl0aW5nIGZvciBqb2IgY29tcGxldGlvbiIKICAgIGZvciBpbWcgaW4gIiR7IXBpZHNbQF19IjsgZG8KICAgICAgICAjIFdhaXQgZm9yIGVhY2ggYmFja2dyb3VuZCB0YXNrIChQSUQpLiBJZiBhbnkgZXJyb3IsIHRoZW4gY29weSB0aGUgaW1hZ2UgaW4gdGhlIGZhaWxlZCBhcnJheSBzbyBpdCBjYW4gYmUgcmV0cmllZCBsYXRlcgogICAgICAgIGlmICEgd2FpdCAiJHtwaWRzWyRpbWddfSI7IHRoZW4KICAgICAgICAgICAgZWNobyAiJHtQUk9HfTogW0VSUk9SXSBQdWxsIGZhaWxlZCBmb3IgY29udGFpbmVyIGltYWdlOiAke2ltZ30gLiBSZXRyeWluZyBsYXRlci4uLiAiCiAgICAgICAgICAgIGZhaWxlZF9jb3BpZXMrPSgiJHtpbWd9IikgIyBGYWlsZWQsIHRoZW4gYWRkIHRoZSBpbWFnZSB0byBiZSByZXRyaWV2ZWQgbGF0ZXIKICAgICAgICBmaQogICAgZG9uZQp9CgojCiMgcmV0cnlfaW1hZ2VzOiBSZXRyeSBsb2FkaW5nIGFueSBmYWlsZWQgaW1hZ2VzIGludG8gY29udGFpbmVyIHN0b3JhZ2UKIwpmdW5jdGlvbiByZXRyeV9pbWFnZXMgewogICAgbG9jYWwgdG90YWxfY29waWVzPSR7I2ZhaWxlZF9jb3BpZXNbQF19CgogICAgaWYgWyAiJHt0b3RhbF9jb3BpZXN9IiAtZXEgMCBdOyB0aGVuCiAgICAgICAgcmV0dXJuIDAKICAgIGZpCgogICAgbG9jYWwgcmM9MAogICAgbG9jYWwgdGFnCiAgICBsb2NhbCBjdXJyZW50X2NvcHk9MAoKICAgIGVjaG8gIiR7UFJPR306IFtSRVRSWUlOR10iCiAgICBmb3IgZmFpbGVkX2NvcHkgaW4gIiR7ZmFpbGVkX2NvcGllc1tAXX0iOyBkbwogICAgICAgIGN1cnJlbnRfY29weT0kKChjdXJyZW50X2NvcHkrMSkpCgogICAgICAgIGVjaG8gIiR7UFJPR306IFtSRVRSWV0gUmV0cnlpbmcgZmFpbGVkIGltYWdlIHB1bGw6ICR7ZmFpbGVkX2NvcHl9IgoKICAgICAgICB0YWc9JChncmVwICJeJHt1cml9PSIgIiR7TUFQUElOR19GSUxFfSIgfCBzZWQgJ3MvLio6Ly8nKQogICAgICAgIGNvcHlfaW1hZ2UgIiR7Y3VycmVudF9jb3B5fSIgIiR7dG90YWxfY29waWVzfSIgIiR7dXJpfSIgIiR7dGFnfSIKICAgICAgICByYz0kPwogICAgZG9uZQoKICAgIGVjaG8gIiR7UFJPR306IFtJTkZPXSBJbWFnZSBsb2FkIGRvbmUiCiAgICByZXR1cm4gIiR7cmN9Igp9CgppZiBbWyAiJHtCQVNIX1NPVVJDRVswXX0iID0gIiR7MH0iIF1dOyB0aGVuCiAgICAjCiAgICAjIFByb2Nlc3MgY21kbGluZSBhcmd1bWVudHMKICAgICMKCiAgICBsb25nb3B0cz0oCiAgICAgICAgImhlbHAiCiAgICAgICAgImxhYmVsOiIKICAgICkKCiAgICBsb25nb3B0c19zdHI9JChJRlM9LDsgZWNobyAiJHtsb25nb3B0c1sqXX0iKQoKICAgIGlmICEgT1BUUz0kKGdldG9wdCAtbyAiaGw6IiAtLWxvbmcgIiR7bG9uZ29wdHNfc3RyfSIgLS1uYW1lICIkMCIgLS0gIiRAIik7IHRoZW4KICAgICAgICB1c2FnZQogICAgICAgIGV4aXQgMQogICAgZmkKCiAgICBldmFsIHNldCAtLSAiJHtPUFRTfSIKCiAgICB3aGlsZSA6OyBkbwogICAgICAgIGNhc2UgIiQxIiBpbgogICAgICAgICAgICAtbHwtLWxhYmVsKQogICAgICAgICAgICAgICAgRlM9Ii9kZXYvZGlzay9ieS1wYXJ0bGFiZWwvJHsyfSIKICAgICAgICAgICAgICAgIHNoaWZ0IDIKICAgICAgICAgICAgICAgIDs7CiAgICAgICAgICAgIC0tKQogICAgICAgICAgICAgICAgc2hpZnQKICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICA7OwogICAgICAgICAgICAtaHwtLWhlbHApCiAgICAgICAgICAgICAgICB1c2FnZQogICAgICAgICAgICAgICAgOzsKICAgICAgICAgICAgKikKICAgICAgICAgICAgICAgIHVzYWdlCiAgICAgICAgICAgICAgICA7OwogICAgICAgIGVzYWMKICAgIGRvbmUKCiAgICBmYWlsZWRfY29waWVzPSgpICMgQXJyYXkgdGhhdCB3aWxsIGluY2x1ZGUgYWxsIHRoZSBpbWFnZXMgdGhhdCBmYWlsZWQgdG8gYmUgcHVsbGVkCgogICAgbW91bnRfZGF0YQoKICAgIGxvYWRfaW1hZ2VzCgogICAgaWYgISByZXRyeV9pbWFnZXM7IHRoZW4KICAgICAgICBlY2hvICIke1BST0d9OiBbRkFJTF0gJHsjZmFpbGVkX2NvcGllc1tAXX0gaW1hZ2VzIHdlcmUgbm90IGxvYWRlZCBzdWNjZXNzZnVsbHksIGFmdGVyICQoKFNFQ09ORFMtU1RBUlQpKSBzZWNvbmRzIiAjbnVtYmVyIG9mIGZhaWxpbmcgaW1hZ2VzCiAgICAgICAgZXhpdCAxCiAgICBlbHNlCiAgICAgICAgZWNobyAiJHtQUk9HfTogW1NVQ0NFU1NdIEFsbCBpbWFnZXMgd2VyZSBsb2FkZWQsIGluICQoKFNFQ09ORFMtU1RBUlQpKSBzZWNvbmRzIgogICAgICAgIGV4aXQgMAogICAgZmkKZmkK"
        }
      }
    ]
  }
}
`)

func discoveryBeautyIgnBytes() ([]byte, error) {
	return _discoveryBeautyIgn, nil
}

func discoveryBeautyIgn() (*asset, error) {
	bytes, err := discoveryBeautyIgnBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "discovery-beauty.ign", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _extractImagesSh = []byte(`#!/bin/bash
#
# Utility for loading prestaged images during node installation
#

PROG=$(basename "$0")

DATADIR="/tmp/prestaging"
FS="/dev/disk/by-partlabel/data"

# Determine the image list from the script name, extract-ai.sh or extract-ocp.sh
IMG_GROUP=$(echo "${PROG}" | sed -r 's/.*extract-(.*)\.sh/\1/')
IMG_LIST_FILE="${DATADIR}/${IMG_GROUP}-images.txt"
MAPPING_FILE="${DATADIR}/mapping.txt"

# Set the parallelization job pool size to 80% of the cores
CPUS=$(nproc --all)
MAX_CPU_MULT=0.8
JOB_POOL_SIZE=$(jq -n "$CPUS*$MAX_CPU_MULT" | cut -d . -f1)

# Get initial starting point for info log at end of execution
START=${SECONDS}

#
# cleanup: Clean up resources on exit
#
function cleanup {
    cd /
    if mountpoint -q "${DATADIR}"; then
        umount "${DATADIR}"
    fi

    rm -rf "${DATADIR}"
}

trap cleanup EXIT

#
# usage:
#
function usage {
    cat <<EOF
Usage: ${PROG} [ --label <partition-label> ]

Parameters:
    --label <partition-label>      Label for partition that holds the downloaded images and associated files.
                                   Default: data

EOF
    exit 1
}

#
# mount_data:
#
function mount_data {
    if ! mkdir -p "${DATADIR}"; then
        echo "${PROG}: [FAIL] Failed to create ${DATADIR}"
        exit 1
    fi

    if [ ! -b "${FS}" ]; then
        echo "${PROG}: [FAIL] Not a block device: ${FS}"
        exit 1
    fi

    if ! mount "${FS}" "${DATADIR}"; then
        echo "${PROG}: [FAIL] Failed to mount ${FS}"
        exit 1
    fi

    for f in "${IMG_LIST_FILE}" "${MAPPING_FILE}"; do
        if [ ! -f "${f}" ]; then
            echo "${PROG}: [FAIL] Could not find ${f}"
            exit 1
        fi
    done

    if ! pushd "${DATADIR}"; then
        echo "${PROG}: [FAIL] Failed to chdir to ${DATADIR}"
        exit 1
    fi
}

#
# copy_image: Function that handles extracting an image tarball and copying it into container storage.
#             Launched in background for parallelization, or inline for retries
#
function copy_image {
    local current_copy=$1
    local total_copies=$2
    local uri=$3
    local tag=$4
    local rc=0
    local name=

    echo "${PROG}: [DEBUG] Extracting image ${uri}"
    name=$(basename "${uri/:/_}")
    if ! tar --use-compress-program=pigz -xf "${name}.tgz"; then
        echo "${PROG}: [ERROR] Could not extract the image ${name}.tgz"
        return 1
    fi

    if [[ "${IMG_GROUP}" = "ai" && -n "${tag}" && "${uri}" =~ "@sha" ]]; then
        # During the AI loading stage, if the image has a tag, load that into container storage as well
        echo "${PROG}: [INFO] Copying ${uri}, with tag ${tag} [${current_copy}/${total_copies}]"
        notag=${uri/@*}
        skopeo copy --retry-times 10 "dir://${PWD}/${name}" "containers-storage:${uri}" -q && \
            skopeo copy --retry-times 10 "dir://${PWD}/${name}" "containers-storage:${notag}:${tag}" -q
        rc=$?
    else
        echo "${PROG}: [INFO] Copying ${uri} [${current_copy}/${total_copies}]"
        skopeo copy --retry-times 10 "dir://${PWD}/${name}" "containers-storage:${uri}" -q
        rc=$?
    fi

    echo "${PROG}: [INFO] Removing folder for ${uri}"
    rm -rf "${name}"

    return ${rc}
}

#
# load_images: Launch jobs to prestage images from the appropriate list file
#
function load_images {
    local -A pids # Hash that include the images pulled along with their pids to be monitored by wait command
    local -a images
    mapfile -t images < <( sort -u "${IMG_LIST_FILE}" )

    local total_copies=${#images[@]}
    local current_copy=0
    local job_count=0

    echo "${PROG}: [INFO] Ready to extract ${total_copies} images using $JOB_POOL_SIZE simultaneous processes"

    for uri in "${images[@]}"; do
        current_copy=$((current_copy+1))

        # Check that we've got free space in the job pool
        while [ "${job_count}" -ge "${JOB_POOL_SIZE}" ]; do
            sleep 0.1
            job_count=$(jobs | wc -l)
        done

        echo "${PROG}: [DEBUG] Processing image ${uri}"
        if podman image exists "${uri}"; then
            echo "${PROG}: [INFO] Skipping existing image ${uri} [${current_copy}/${total_copies}]"
            continue
        fi

        tag=$(grep "^${uri}=" "${MAPPING_FILE}" | sed 's/.*://')
        copy_image "${current_copy}" "${total_copies}" "${uri}" "${tag}" &

        pids[${uri}]=$! # Keeping track of the PID and container image in case the pull fails
    done

    echo "${PROG}: [DEBUG] Waiting for job completion"
    for img in "${!pids[@]}"; do
        # Wait for each background task (PID). If any error, then copy the image in the failed array so it can be retried later
        if ! wait "${pids[$img]}"; then
            echo "${PROG}: [ERROR] Pull failed for container image: ${img} . Retrying later... "
            failed_copies+=("${img}") # Failed, then add the image to be retrieved later
        fi
    done
}

#
# retry_images: Retry loading any failed images into container storage
#
function retry_images {
    local total_copies=${#failed_copies[@]}

    if [ "${total_copies}" -eq 0 ]; then
        return 0
    fi

    local rc=0
    local tag
    local current_copy=0

    echo "${PROG}: [RETRYING]"
    for failed_copy in "${failed_copies[@]}"; do
        current_copy=$((current_copy+1))

        echo "${PROG}: [RETRY] Retrying failed image pull: ${failed_copy}"

        tag=$(grep "^${uri}=" "${MAPPING_FILE}" | sed 's/.*://')
        copy_image "${current_copy}" "${total_copies}" "${uri}" "${tag}"
        rc=$?
    done

    echo "${PROG}: [INFO] Image load done"
    return "${rc}"
}

if [[ "${BASH_SOURCE[0]}" = "${0}" ]]; then
    #
    # Process cmdline arguments
    #

    longopts=(
        "help"
        "label:"
    )

    longopts_str=$(IFS=,; echo "${longopts[*]}")

    if ! OPTS=$(getopt -o "hl:" --long "${longopts_str}" --name "$0" -- "$@"); then
        usage
        exit 1
    fi

    eval set -- "${OPTS}"

    while :; do
        case "$1" in
            -l|--label)
                FS="/dev/disk/by-partlabel/${2}"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -h|--help)
                usage
                ;;
            *)
                usage
                ;;
        esac
    done

    failed_copies=() # Array that will include all the images that failed to be pulled

    mount_data

    load_images

    if ! retry_images; then
        echo "${PROG}: [FAIL] ${#failed_copies[@]} images were not loaded successfully, after $((SECONDS-START)) seconds" #number of failing images
        exit 1
    else
        echo "${PROG}: [SUCCESS] All images were loaded, in $((SECONDS-START)) seconds"
        exit 0
    fi
fi
`)

func extractImagesShBytes() ([]byte, error) {
	return _extractImagesSh, nil
}

func extractImagesSh() (*asset, error) {
	bytes, err := extractImagesShBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "extract-images.sh", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testBootBeautyIgn = []byte(`{
  "ignition": {
    "version": "3.1.0"
  },
  "systemd": {
    "units": [
      {
        "name": "precache-ocp-images.service",
        "enabled": true,
        "contents": "[Unit]\nDescription=Truncated for test usage\nExecStart=bash /usr/local/bin/extract-ocp.sh --label data\nTimeoutStopSec=60\n"
      }
    ]
  },
  "storage": {
    "files": [
      {
        "overwrite": true,
        "path": "/usr/local/bin/extract-ocp.sh",
        "mode": 493,
        "user": {
          "name": "root"
        },
        "contents": {
          "source": "Truncated for test usage"
        }
      }
    ]
  }
}
`)

func testBootBeautyIgnBytes() ([]byte, error) {
	return _testBootBeautyIgn, nil
}

func testBootBeautyIgn() (*asset, error) {
	bytes, err := testBootBeautyIgnBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test-boot-beauty.ign", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _testDiscoveryBeautyIgn = []byte(`{
  "ignition": {
    "version": "3.1.0"
  },
  "systemd": {
    "units": [
      {
        "name": "precache-images.service",
        "enabled": true,
        "contents": "[Unit]\nDescription=Truncated for test usage\nExecStart=bash /usr/local/bin/extract-ai.sh --label data\n"
      }
    ]
  },
  "storage": {
    "files": [
      {
        "overwrite": true,
        "path": "/usr/local/bin/extract-ai.sh",
        "mode": 493,
        "user": {
          "name": "root"
        },
        "contents": {
          "source": "Truncated for test usage"
        }
      }
    ]
  }
}
`)

func testDiscoveryBeautyIgnBytes() ([]byte, error) {
	return _testDiscoveryBeautyIgn, nil
}

func testDiscoveryBeautyIgn() (*asset, error) {
	bytes, err := testDiscoveryBeautyIgnBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "test-discovery-beauty.ign", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"boot-beauty.ign":           bootBeautyIgn,
	"discovery-beauty.ign":      discoveryBeautyIgn,
	"extract-images.sh":         extractImagesSh,
	"test-boot-beauty.ign":      testBootBeautyIgn,
	"test-discovery-beauty.ign": testDiscoveryBeautyIgn,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//
//	data/
//	  foo.txt
//	  img/
//	    a.png
//	    b.png
//
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}

var _bintree = &bintree{nil, map[string]*bintree{
	"boot-beauty.ign":           {bootBeautyIgn, map[string]*bintree{}},
	"discovery-beauty.ign":      {discoveryBeautyIgn, map[string]*bintree{}},
	"extract-images.sh":         {extractImagesSh, map[string]*bintree{}},
	"test-boot-beauty.ign":      {testBootBeautyIgn, map[string]*bintree{}},
	"test-discovery-beauty.ign": {testDiscoveryBeautyIgn, map[string]*bintree{}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}
